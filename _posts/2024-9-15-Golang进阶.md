# 一、架构

## GMP模型

gmp = goroutine + machine + processor

### Goroutinue

- 协程：轻量级线程，又称“用户级线程”。创建、销毁、调度在用户态完成，会阻塞同一线程的所有协程

- Golang中的协程，与线程映射关系M：N
- 利用多个线程实现并行
- 有自己的运行栈、状态，栈空间大小动态扩缩
- 需要绑定到p执行

### Processor

- p 即 processor，是 golang 中的调度器，它保存G的上下文信息，并提供给m运行。这样解绑了G和M，保证G可以运行到其他M上
- p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS （默认为CPU核心数）进行设定

### Machine

- M是线程的抽象
- 调度G前要和P绑定
- **g0**：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1
  - m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换
  - 当 g0 找到可执行的 g 时，会调用 *gogo* 方法，调度 g 执行用户定义的任务
  - 当 g 需要主动让渡或被动调度时，会触发 *mcall* 方法，将执行权重新交还给 g0.

### 三种队列

- p的本地队列：存放p调度的G
- 全局队列：存放还没有调度的G，访问需要加锁
- wait队列：存放IO阻塞就绪的G

### work-stealing机制

当一个p的本地队列为空时，可以窃取其他p的本地队列

### 调度类型

- 主动调度
  - 调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行
- 被动调度
  - g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度
  - 底层会走进 gopark 方法（runtime/proc.go）
  - goready 方法通常与 gopark 方法成对出现，能够将 g 从阻塞态中恢复，重新进入等待执行的状态
- 正常调度
  - g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度
- 抢占调度
  - g 执行系统调用超过指定的时长，此时将 p 和 g 解绑，用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度
  - 前三种有go调度，但抢占调度由全局监控协程 **monitor g 来进行，这个 g 直接与一个 m 进行绑定**，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预

### 调度流程

1. 全局流程

   - 以 g0 -> g -> g0 的一轮循环为例进行串联
   - g0 执行 schedule() 函数，寻找到用于执行的 g，并执行g
   - g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g
   - g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中
   - g0 执行 schedule() 函数，开启新一轮循环

2. findRunnable

   p的调度流程，由于work-stealing机制p对本地队列操作需要加锁

   ![](../images/2024-9-15-Golang进阶/640.png)

   - 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中
   - 还会额外将一个 g 从全局队列转移到 p 的本地队列，让全局队列中的 g 也得到更充分的执行机会
   - 本地队列已满，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力

3. execute

   - 更新 g 的状态信息，建立 g 与 m 之间的绑定关系
   - 更新 p 的总调度次数
   - 调用 gogo 方法，执行 goroutine 中的任务

4. gosched_m

   当前g主动调用mcall将执行权让给g0，g0调用gosched_m方法

   - 将g的状态更新为RUNABLE
   - 解绑 g 和 m，并将g添加到全局队列（加锁）
   - 开始新一轮调度，schedule()

5. park_m

   g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态

   - 将当前 g 的状态由 running 改为 waiting
   - 将 g 与 m 解绑
   - 执行新一轮的调度 schedule

6. goready

   当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态

   - 先将 g 的状态从waiting改为RUNABLE
   - 加入到唤醒者p的本地队列，满了移动到全局队列

7. goexit0

   当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法

   - 将g的状态设置为dead
   - 解绑g和m，开启新一轮调度

### 参考

- [Golang GMP 原理 (qq.com)](https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg)

## 垃圾回收

## 内存模型

# 二、内置对象底层原理

## slice

### 三个属性

- array unsafe.Pointer ，指向内存空间的首地址
- len int
- cap int

### 截取

​	len(s) = 10，cap(s) = 12

1. s1 = s[8:]，len(s1) = 2，cap(s1) = 4
2. s2 = s[:2]，len(s2) = 2，cap(s2) = 12

### 扩容策略

1. 预期容量小于原容量，panic
2. 切片元素大小为0，直接复用一个全局的 zerobase 实例，直接返回
3. 预期容量超过老容量两倍，直接采用预期容量
4. 老容量小于256，直接采用老容量的2倍
5. 老容量大于256，则在老容量基础上扩容1/4，并且加上 256 * 3 / 4 = 192的数值，直到老容量大于等于预期容量
6. 计算预期空间大小 = 新容量 * 元素大小，更具mspan等级制度得到空间大小，才能得到实际新容量

### 参考

- https://mp.weixin.qq.com/s/uNajVcWr4mZpof1eNemfmQ

## context

### 属性

```go
type Context interface{
    Deadline() (deadline time.Time, ok bool) //返回ctx的过期时间
    Done() <-chan struct{} // 返回标识ctx结束的chan
    Err() error // 返回ctx错误
    Value(key any) any //键值对 key-value
}
```

### emptyCtx

```go
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
	return
}

func (*emptyCtx) Done() <-chan struct{} {
	return nil
}

func (*emptyCtx) Err() error {
	return nil
}

func (*emptyCtx) Value(key any) any {
	return nil
}
```

context.Background() 和 context.TODO(）返回*emptyCtx

### cancelCtx

```go
type cancelCtx struct {
	Context                        // 父级ctx

	mu       sync.Mutex            // 协调并发场景下的资源获取
    done     atomic.Value          // 标识ctx是否结束，存储chan struct{}
	children map[canceler]struct{} // 子ctx的集合
	err      error                 // 
	cause    error                 //
}

type canceler interface {
	cancel(removeFromParent bool, err, cause error)
	Done() <-chan struct{}
}
```

- context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)
  - 构造canceler
  - 开启守护进程，保证父终止后子也终止
- cancelCtx.cancel(removeFromParent bool, err error) 
  - 加锁校验cancelCtx的err是否为nil，不为nil说明已经返回，直接解锁返回；为nil，将err赋给cancelCtx的err
  - 处理cnacelCtx的chan，已经初始化则close，否则注入closedChan
  - 处理子context，一次cancel
  - 根据removeFromParent判断是否从父context中移除该cancelCtx

### timerCtx

```go
type timerCtx struct {
	*cancelCtx 			// 继承cancelCtx
	timer *time.Timer   // 过期时间终止

	deadline time.Time // 过期时间
}
```

- Deadline() (deadline time.Time, ok bool)：context.Context interface 下的 Deadline api 仅在 timerCtx 中有效，由于展示其过期时间

- timerCtx.cancel(removeFromParent bool, err error) 

  - 判断是否需要手动从 parent 的 children set 中移除，若是则进行处理
  - 加锁，停止 time.Timer，解锁返回

- context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)

  - 校验 parent 的过期时间是否早于自己，若是，则构造一个 cancelCtx 返回即可
  - 构造出一个新的 timerCtx， 启动守护方法，同步 parent 的 cancel 事件到子 context
  - 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回DeadlineExceeded 的错误

  - 加锁，启动 time.Timer，设定一个延时时间，即达到过期时间后会终止该 timerCtx，并返回 DeadlineExceeded 的错误，解锁
  - 返回 timerCtx，已经一个封装了 cancel 逻辑的闭包 cancel 函数.

### valueCtx

```go
type valueCtx struct {
	Context
	key, val any
}

func (c *valueCtx) Value(key any) any {
    // 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value
    if c.key == key {
        return c.val
    }
    // 假如不等，则从 parent context 中依次向上寻找
    return value(c.Context, key)
}
```

- value(c Context, key any) any

  - 启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配
  - 中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式
  - 找到匹配的 key，则将该组 value 进行返回

- WithValue(parent Context, key, val any) Context 

  - parent context 为空，key 为空，key 的类型不可比较，panic

  - 包括 parent context 以及 kv对，返回一个新的 valueCtx

### 参考

- [Golang context 实现原理](https://mp.weixin.qq.com/s/AavRL-xezwsiQLQ1OpLKmA)

## chan

### 属性

```go
type hchan struct {
	qcount   uint           // 存在元素数量
	dataqsiz uint           // chan元素容量
	buf      unsafe.Pointer // 数组首地址
	elemsize uint16 // 元素大小
	closed   uint32	// 标识是否关闭
	elemtype *_type // 元素类型
	sendx    uint   // 发送元素的索引
	recvx    uint   // 接收元素索引
	recvq    waitq  // 读协程队列
	sendq    waitq  // 写协程队列
	lock mutex		// 锁
}

type waitq struct {
	first *sudog // 队列头部
	last  *sudog // 队列尾部
}

type sudog struct {
	g *g				// 协程
	next *sudog			// 队列中的下一个节点
	prev *sudog			// 队列中的前一个节点
	elem unsafe.Pointer // 读取/写入 channel 的数据的容器
	acquiretime int64
	releasetime int64
	ticket      uint32	// 票据，用于实现公平的等待队列调度
	isSelect bool 		// 标识当前协程是否处在 select 多路复用的流程中
	success bool		// 标记通道通信是否成功。如果 goroutine 因为接收到数据而被唤醒，则为 true；如果因为通道关闭而被唤醒，则为 false
	parent   *sudog 	// semaRoot binary tree
	waitlink *sudog 	// g.waiting list or semaRoot
	waittail *sudog 	// semaRoot
	c        *hchan 	// 标识与当前 sudog 交互的 chan
}
```

### 异常情况

1. 对于未初始化的 chan，写入操作会引发死锁
2.  对于已关闭的 chan，写入操作会引发 panic

### 写流程（chansend ）

- #### 写时存在阻塞读协程（直接绕过缓冲区）

  - 加锁，从阻塞队列取出sudog元素
  - 在 send 方法中，会基于 memmove 方法，直接将元素拷贝交给 sudog 对应的 goroutine
  - 在 send 方法中会完成解锁动作

- #### 写时无阻塞读协程但环形缓冲区仍有空间

  - 加锁，将当前元素添加到环形缓冲区 sendx 对应的位置
  - sendx++，qcount++，解锁，返回

- #### 写时无阻塞读协程且环形缓冲区无空间

  - 加锁
  - 构造封装当前 goroutine 的 sudog 对象， 完成指针指向，建立 sudog、goroutine、channel 之间的指向关系
  - 把 sudog 添加到当前 channel 的阻塞写协程队列中
  - park 当前协程
  - 若协程从 park 中被唤醒，则回收 sudog
  - 解锁，返回

### 读流程（chanrecv）

- #### 读空 channel（c == nil）

  - park 挂起，引起死锁

- #### channel 已关闭且内部无元素

  - 直接解锁返回

- #### 读时有阻塞的写协程

  - 加锁
  - 从阻塞写协程队列获取写协程
  - 若channel无缓冲区，直接读取写协程元素，唤醒写协程
  - 若channel有缓冲区，读取缓冲区头部元素，并将写协程元素写入缓冲区尾部，唤醒协程
  - 解锁返回

- #### 读时无阻塞写协程且缓冲区有元素

  - 加锁
  - 获取到 recvx 对应位置的元素
  -  recvx++，qcount--，解锁，返回

- #### 读时无阻塞写协程且缓冲区无元素

  - 加锁
  - 构造封装当前 goroutine 的 sudog 对象， 完成指针指向，建立 sudog、goroutine、channel 之间的指向关系
  - 把 sudog 添加到当前 channel 的阻塞读协程队列中
  - park 当前协程
  - 若协程从 park 中被唤醒，则回收 sudog
  - 解锁，返回

### 非阻塞模式

只有在select多路复用的模式中才会进入非阻塞模式

```go
func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) {
    return chansend(c, elem, false, getcallerpc())
}

func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool) {
    return chanrecv(c, elem, false) // false表示非阻塞模式
}
```

### 读取channel方法

```go
ch := make(chan int, 2)
got1 := <- ch
got2,ok := <- ch
```

被编译成两种方法

```go
func chanrecv1(c *hchan, elem unsafe.Pointer) {
    chanrecv(c, elem, true)
}

func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
    _, received = chanrecv(c, elem, true)
    return
}
```

### 关闭channel

- 检查channel是否为nil
- 加锁
- 将读协程加入glist
- 将写协程加入glist
- 解锁
- 唤醒glist索引协程（goready）

### 参考

- [Golang channel 实现原理](https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw)

## WaitGroup

### 结构

- ncopy 防拷贝标志，只能引用使用
- state1 uint64 高32位表示计数器数值，第32位表示wait阻塞方法数量
- state2 uint64 阻塞/唤醒goroutinue的信号量

### Add

- 调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值
- 执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回
- 若本次 Add 操作后， WaitGroup 计数器被清零了，则需要把 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic
- 唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式

### Done

- WaitGroup.Add(-1)

### Wait

- for 循环开启**自旋**流程
- 若计数器数值 已经是 0 了，则无需阻塞 goroutine，直接返回即可
- 若计数器数值 大于 0，代表当前 goroutine 需要被阻塞挂起
- 基于 cas，将 state1 低 32 位的数值加 1
- 调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式
- 当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了

### 参考

- [Golang WaitGroup 实现原理](https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg)

## map

## sync.map

## sync.Cond

```go
type Cond struct {
	noCopy noCopy // 防止复制
	L Locker	  // 锁
	notify  notifyList // 需要唤醒的阻塞队列
	checker copyChecker// 防止复制
}

type notifyList struct {
	wait   uint32 //调用 Cond.Wait() 方法的次数
	notify uint32 //goroutine 被唤醒的次数
	lock   uintptr // key field of the mutex
	head   unsafe.Pointer //链表的头尾节点
	tail   unsafe.Pointer
}
```

### Cond.Wait

```go
func (c *Cond) Wait() {
	c.checker.check() //检查 Cond 是否在使用过后被拷贝，是则 panic
	t := runtime_notifyListAdd(&c.notify) //阻塞链表 wait 统计数加 1
	c.L.Unlock() //当前协程释放锁，因为接下来即将被操作系统 park
	runtime_notifyListWait(&c.notify, t) //将当前协程包装成节点，添加到 Cond 的阻塞队列当中，并调用 park 操作将当前协程挂起
	c.L.Lock() //协程被唤醒后，重新尝试获取锁
}
```

### Cond.Signal

```go
func (c *Cond) Signal() {
	c.checker.check()//检查 Cond 是否在使用过后被拷贝，是则 panic
	runtime_notifyListNotifyOne(&c.notify) //该 Cond 阻塞链表 notify 统计数加 1;从头开始遍历阻塞链表，唤醒一个等待时间最长的 goroutine
}
```

### Cond.Broadcast

```go
func (c *Cond) Broadcast() {
	c.checker.check()
	runtime_notifyListNotifyAll(&c.notify) //  取 wait 值赋值给 notify;唤醒阻塞链表所有节点
}
```

## sync.Pool

```go
type Pool struct {
	noCopy noCopy // 防拷贝标志
	local     unsafe.Pointer // [P]poolLocal 的数组，P为process个数
	localSize uintptr
	victim     unsafe.Pointer // 经过一轮 gc 回收，暂存的上一轮 local
	victimSize uintptr      
	New func() any			// 用户指定的工厂函数
}

// Local per-P Pool appendix.
type poolLocalInternal struct {
	private any       // 对应于某个 P 的私有元素，操作时无需加锁
	shared  poolChain //某个 P 下的共享元素链表，由于各 P 都有可能访问，因此需要加锁
}

//  poolLocal 为 Pool 中对应于某个 P 的缓存数据
type poolLocal struct {
	poolLocalInternal
	pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte
}
```

### Pool.pin

```go
func (p *Pool) pin() (*poolLocal, int) {
	pid := runtime_procPin()
	s := runtime_LoadAcquintptr(&p.localSize) // load-acquire
	l := p.local                              // load-consume
	if uintptr(pid) < s {
		return indexLocal(l, pid), pid
	}
	return p.pinSlow()
}
```

- pin 方法内部通过 native 方法 runtime_procPin 取出当前 P 的 index，并且将当前 goroutine 与 P 进行绑定，短暂处于不可抢占状态；
- 如果是首次调用 pin 方法，则会走进 pinSlow 方法；
- 在pinSlow 方法中，会完成 Pool.local 的初始化，并且将当前 Pool 添加到全局的 allPool 数组中，用于 gc 回收

### Pool.Get

```go
func (p *Pool) Get() any {
	if race.Enabled {
		race.Disable()
	}
	l, pid := p.pin() 	 //绑定当前 goroutine 与 P
	x := l.private  	//获取 P 缓存数据的私有元素 private
	l.private = nil
	if x == nil {
		x, _ = l.shared.popHead() //尝试取 P 缓存数据中共享元素链表的头元素
		if x == nil {
			x = p.getSlow(pid) //试取其他 P 缓存数据中共享元素链表的尾元素;在 Pool.getSlow 方法中，倘若前一步失败，则尝试从上轮 gc 前缓存中取元素（victim）
		}
	}
	runtime_procUnpin() // 解绑 当前 goroutine 与 P
	if race.Enabled {
		race.Enable()
		if x != nil {
			race.Acquire(poolRaceAddr(x))
		}
	}
	if x == nil && p.New != nil {
		x = p.New() // 没能获取到p的私有元素或共享元素，调用构造方法返回
	}
	return x
}
```

### Pool.Put

```go
func (p *Pool) Put(x any) {
	if x == nil {
		return
	}
	if race.Enabled {
		if fastrandn(4) == 0 {
			// Randomly drop x on floor.
			return
		}
		race.ReleaseMerge(poolRaceAddr(x))
		race.Disable()
	}
	l, _ := p.pin()
	if l.private == nil {
		l.private = x
	} else {
		l.shared.pushHead(x)
	}
	runtime_procUnpin()
	if race.Enabled {
		race.Enable()
	}
}
```

- 判断存入元素 x 非空
- 调用 Pool.pin 绑定当前 goroutine 与 P，并获取 P 的缓存数据
- P 缓存数据中的私有元素为空，则将 x 置为其私有元素
- P 缓存数据中的私有元素不为空，则将 x 添加到 P 缓存数据共享链表的末尾
- 解绑当前 goroutine 与 P

### 小结

1. 初始化pool，拥有一个len(p)的数组，每个数组有缓存数据
2. get和put时先获取g的pid，定位到数组
3. 操作对应数组的链表

### 回收机制

存入 pool 的对象会不定期被 go 运行时回收，因此 pool 没有容量概念，即便大量存入元素，也不会发生内存泄露

- 每次 gc 时，会将上一轮的 oldPools 清空，并将本轮 allPools 的元素赋给 oldPools，allPools 置空；
- 新置入 oldPools 的元素统一将 local 转移到 victim，并且将 local 置为空
- 每个 Pool 首次执行 Get 方法时，会在内部首次调用 pinSlow 方法内将该 pool 添加到迁居的 allPools 数组中

### 参考

- [Golang 协程池](https://mp.weixin.qq.com/s/Uctu_uKHk5oY0EtSZGUvsA)

## HTTP

## EPOLL

# 三、框架

## Gin
