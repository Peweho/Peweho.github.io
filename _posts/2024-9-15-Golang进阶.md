# 一、架构

## GMP模型

gmp = goroutine + machine + processor

### Goroutinue

- 协程：轻量级线程，又称“用户级线程”。创建、销毁、调度在用户态完成，会阻塞同一线程的所有协程

- Golang中的协程，与线程映射关系M：N
- 利用多个线程实现并行
- 有自己的运行栈、状态，栈空间大小动态扩缩
- 需要绑定到p执行

### Processor

- p 即 processor，是 golang 中的调度器，它保存G的上下文信息，并提供给m运行。这样解绑了G和M，保证G可以运行到其他M上
- p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS （默认为CPU核心数）进行设定

### Machine

- M是线程的抽象
- 调度G前要和P绑定
- **g0**：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1
  - m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换
  - 当 g0 找到可执行的 g 时，会调用 *gogo* 方法，调度 g 执行用户定义的任务
  - 当 g 需要主动让渡或被动调度时，会触发 *mcall* 方法，将执行权重新交还给 g0.

### 三种队列

- p的本地队列：存放p调度的G
- 全局队列：存放还没有调度的G，访问需要加锁
- wait队列：存放IO阻塞就绪的G

### work-stealing机制

当一个p的本地队列为空时，可以窃取其他p的本地队列

### 调度类型

- 主动调度
  - 调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行
- 被动调度
  - g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度
  - 底层会走进 gopark 方法（runtime/proc.go）
  - goready 方法通常与 gopark 方法成对出现，能够将 g 从阻塞态中恢复，重新进入等待执行的状态
- 正常调度
  - g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度
- 抢占调度
  - g 执行系统调用超过指定的时长，此时将 p 和 g 解绑，用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度
  - 前三种有go调度，但抢占调度由全局监控协程 **monitor g 来进行，这个 g 直接与一个 m 进行绑定**，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预

### 调度流程

1. 全局流程

   - 以 g0 -> g -> g0 的一轮循环为例进行串联
   - g0 执行 schedule() 函数，寻找到用于执行的 g，并执行g
   - g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g
   - g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中
   - g0 执行 schedule() 函数，开启新一轮循环

2. findRunnable

   p的调度流程，由于work-stealing机制p对本地队列操作需要加锁

   ![](https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZv7BArqKhicntmW5bZrgickiagTfts03QKPP4bL5OKSZvTUYre5eicdTk7TJaRpOhFgdO6sZmSX0KWC5A/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

   - 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中
   - 还会额外将一个 g 从全局队列转移到 p 的本地队列，让全局队列中的 g 也得到更充分的执行机会
   - 本地队列已满，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力

3. execute

   - 更新 g 的状态信息，建立 g 与 m 之间的绑定关系
   - 更新 p 的总调度次数
   - 调用 gogo 方法，执行 goroutine 中的任务

4. gosched_m

   当前g主动调用mcall将执行权让给g0，g0调用gosched_m方法

   - 将g的状态更新为RUNABLE
   - 解绑 g 和 m，并将g添加到全局队列（加锁）
   - 开始新一轮调度，schedule()

5. park_m

   g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态

   - 将当前 g 的状态由 running 改为 waiting
   - 将 g 与 m 解绑
   - 执行新一轮的调度 schedule

6. goready

   当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态

   - 先将 g 的状态从waiting改为RUNABLE
   - 加入到唤醒者p的本地队列，满了移动到全局队列

7. goexit0

   当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法

   - 将g的状态设置为dead
   - 解绑g和m，开启新一轮调度

### 参考

- [Golang GMP 原理 (qq.com)](https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg)

## 垃圾回收

## 内存模型

# 二、内置对象底层原理

## slice

### 三个属性

- array unsafe.Pointer ，指向内存空间的首地址
- len int
- cap int

### 截取

​	len(s) = 10，cap(s) = 12

1. s1 = s[8:]，len(s1) = 2，cap(s1) = 4
2. s2 = s[:2]，len(s2) = 2，cap(s2) = 12

### 扩容策略

1. 预期容量小于原容量，panic
2. 切片元素大小为0，直接复用一个全局的 zerobase 实例，直接返回
3. 预期容量超过老容量两倍，直接采用预期容量
4. 老容量小于256，直接采用老容量的2倍
5. 老容量大于256，则在老容量基础上扩容1/4，并且加上 256 * 3 / 4 = 192的数值，直到老容量大于等于预期容量
6. 计算预期空间大小 = 新容量 * 元素大小，更具mspan等级制度得到空间大小，才能得到实际新容量

### 参考

- https://mp.weixin.qq.com/s/uNajVcWr4mZpof1eNemfmQ

## context

## chan

## WaitGroup

### 结构

- ncopy 防拷贝标志，只能引用使用
- state1 uint64 高32位表示计数器数值，第32位表示wait阻塞方法数量
- state2 uint64 阻塞/唤醒goroutinue的信号量

### Add

- 调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值
- 执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回
- 若本次 Add 操作后， WaitGroup 计数器被清零了，则需要把 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic
- 唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式

### Done

- WaitGroup.Add(-1)

### Wait

- for 循环开启自旋流程
- 若计数器数值 已经是 0 了，则无需阻塞 goroutine，直接返回即可
- 若计数器数值 大于 0，代表当前 goroutine 需要被阻塞挂起
- 基于 cas，将 state1 低 32 位的数值加 1
- 调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式
- 当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了

### 参考

- https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg

## map

## sync.map

# 三、框架

## Gin

# 参考

- 

