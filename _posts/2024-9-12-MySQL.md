# 一、架构

# 二、日志

## 2.1、Redo Log

### 2.1.1、作用**

#### (1) **事务的持久性（Durability）**

在数据库系统中，事务的四个重要性质是 **ACID**（原子性、一致性、隔离性、持久性）。Redo Log 确保了事务的 **持久性**，即在事务提交后，事务中的数据修改将持久存在，即使数据库出现崩溃。

#### (2) **崩溃恢复**

当数据库崩溃或宕机时，内存中的数据可能会丢失，但如果事务已提交，Redo Log 会被用来在数据库重启时进行恢复。MySQL 在启动时会检查 Redo Log，重做那些在崩溃前已经提交但尚未写入数据文件中的事务，以恢复到一致的状态。

### 2.1.2. **Redo Log 的工作机制**

**Redo Log** 使用了一种 **WAL（Write-Ahead Logging，预写日志）** 的技术。具体工作流程如下：

1. **写入 Redo Log**： 当有事务进行数据修改时，InnoDB 不会立即将修改的数据写入磁盘，而是先将修改记录在 **Redo Log** 中，并将日志持久化到磁盘上。这是顺序写的过程，效率很高。
2. **事务提交**： 事务在提交时，InnoDB 只需要确保 Redo Log 已经持久化到磁盘，而不用立即将修改的数据页写回磁盘。这就提高了写入性能，因为写日志是顺序写，远比随机写入数据页快得多。
3. **异步刷脏页**： 事务提交后，InnoDB 后台线程会在适当的时候（如内存不足或达到某个时间点）将内存中的修改数据页（脏页）批量写回到磁盘。这样做可以将多个写操作合并，进一步提升性能。
4. **崩溃恢复**： 如果系统在事务提交后崩溃，MySQL 会在重启时读取 Redo Log，并重做这些日志中的操作，将数据恢复到事务提交后的状态。

### 2.1.3. **Redo Log 的结构**

Redo Log 由两部分组成：

- **Log Buffer**：这是在内存中的日志缓冲区，事务执行时，首先将日志写入到这个缓冲区。
- **Log File**：这是持久化的物理日志文件，当日志缓冲区中的内容达到一定量或事务提交时，日志会刷写到磁盘上的 Redo Log 文件中。

Redo Log 文件本身是**固定大小**的环形结构，当日志写满时，会覆盖最老的日志。因此，系统必须确保所有已持久化到磁盘的数据都不会依赖被覆盖的日志。

### 2.1.4. **Checkpoint 机制**

Redo Log 的另一个重要机制是 **Checkpoint**。因为 Redo Log 是环形结构，会不断覆盖最老的日志，所以为了确保日志被覆盖时对应的数据已经写入磁盘，MySQL 会定期触发 Checkpoint，将内存中的脏页刷回磁盘并标记日志的进度，保证在崩溃恢复时，不需要从日志的最开头开始重做。

## 2.2、Binlog

### 2.2.1. 作用

#### (1) **数据恢复**

Binlog 可以用来在崩溃或误操作后恢复数据。MySQL 会将 Binlog 持久化到磁盘，当数据库崩溃或需要回滚某个时间点时，能够通过恢复备份并根据 Binlog 重放相应的日志，恢复数据库状态。

#### (2) **主从复制**

MySQL 的主从复制依赖于 Binlog。主库会将所有数据修改操作记录到 Binlog 中，然后从库会读取主库的 Binlog，并在自己的数据库中执行相同的操作，从而保持与主库的数据一致性。

### 2.2.2. Binlog 的工作机制

- **记录操作**：每当执行数据更改时，MySQL 首先将修改内容记录到 Binlog 日志中，而不是直接修改数据文件。
- 不同的写入方式
  - **Statement 模式**：记录每个执行的 SQL 语句。优点是日志量小，缺点是一些包含不确定函数（如 `NOW()`、`UUID()`）的语句可能导致不同步。
  - **Row 模式**：记录每一行数据的变动，适合复杂的操作。虽然日志量大，但在主从复制中可以更精确地还原数据变更。
  - **Mixed 模式**：根据具体的情况选择 `Statement` 或 `Row` 记录方式。

### 2.2.3. Binlog 与 Redo Log 的区别

- **Binlog** 主要用于数据恢复和主从复制，记录的是对数据库的 **逻辑操作**（如 SQL 语句）。
- Redo Log是 InnoDB 存储引擎特有的日志，用于数据恢复和崩溃恢复，记录的是对 物理数据页的修改
  - **持久性**：Redo Log 确保事务的持久性，即使系统崩溃也能通过重做日志恢复到事务提交的状态。
  - **写入时间**：Redo Log 在事务提交前就已经被写入（顺序写），而 Binlog 是在**事务提交时才被写入**。

### 2.2.4. Binlog 的存储方式

- Binlog 日志是以二进制文件的形式存储在 MySQL 服务器的磁盘上，通常文件名格式为 `mysql-bin.xxxxxx`，每次写满一个文件会创建新的文件。

## 2.3、undolog

**Undo Log** 是 MySQL 中 InnoDB 存储引擎的一种日志机制，主要用于实现 **事务的原子性** 和 **一致性**，以及提供 **MVCC（多版本并发控制）** 支持。它记录了事务在执行修改操作前的数据快照，以便在需要时可以进行回滚操作，从而撤销事务的修改。

### 2.3.1、 **Undo Log 的作用**

#### (1) **回滚事务**

在事务执行过程中，如果事务失败或显式执行了 `ROLLBACK` 操作，InnoDB 需要撤销事务对数据库的所有修改。为了实现这一点，在事务执行修改操作前，InnoDB 会将被修改的数据的**旧值**保存在 **Undo Log** 中。如果需要回滚，MySQL 可以通过 Undo Log 将数据恢复到事务开始之前的状态。

#### (2) **MVCC（多版本并发控制）**

InnoDB 使用 **MVCC（Multi-Version Concurrency Control，多版本并发控制）** 来实现高并发情况下的读写一致性。Undo Log 是 MVCC 的核心机制之一。在 MVCC 模型中，每个事务在读取数据时，可以看到该数据在其启动时的一个一致快照。即使另一个事务正在修改数据，当前事务仍然能够读取修改前的数据版本，这个修改前的版本就是由 Undo Log 来提供的。

#### (3) **快照读（Snapshot Read）**

使用 MVCC 的快照读功能，读操作可以在一个事务中看到数据的旧版本，而不是其他事务尚未提交的修改。这是通过 Undo Log 实现的。每个数据页可以通过 Undo Log 追溯到它之前的版本，从而为不同的事务提供一致的视图。

### 2.3.2、 **Undo Log 的工作机制**

- **写入 Undo Log**：在执行 `INSERT`、`UPDATE` 或 `DELETE` 操作时，InnoDB 会首先将数据修改前的旧值写入 Undo Log。例如，执行 `UPDATE` 时，Undo Log 会记录被修改的行在修改之前的值；执行 `DELETE` 时，会记录被删除的行的完整信息；执行 `INSERT` 时，Undo Log 记录的是删除操作，因为插入操作可以回滚为删除。
- **事务回滚**：当事务需要回滚时，MySQL 会根据 Undo Log 的内容，逐步撤销对数据库的修改，将数据恢复到事务开始前的状态。
- **保存多个版本的数据**：通过 Undo Log，InnoDB 可以保留多个数据版本。当某个事务读取数据时，如果发现数据已经被其他事务修改，那么系统会通过 Undo Log 回退到适合该事务读取的版本。

### 2.3.3、**Undo Log 的类型**

根据具体的操作类型，Undo Log 分为两种主要类型：

- **Insert Undo Log**：当事务执行 `INSERT` 操作时，会生成 Insert Undo Log。如果事务回滚时，可以根据 Insert Undo Log 直接删除插入的记录。事务提交后，Insert Undo Log 会被立即清除，因为一旦事务提交，插入操作无法回滚。
- **Update/Modify Undo Log**：当事务执行 `UPDATE` 或 `DELETE` 操作时，生成 Modify Undo Log。它保存的是修改或删除前的旧数据版本。如果事务回滚时，可以使用 Modify Undo Log 恢复数据。即使事务提交，Modify Undo Log 仍然会保留一段时间，以供 MVCC 使用，因为其他事务可能仍然需要读取提交前的数据快照。

### 2.3.4、**Undo Log 的存储与清理**

- **Undo Log 的存储**：Undo Log 数据会保存在 **Undo 段** 中，通常位于 **共享表空间** 或 **独立的 Undo 表空间** 中。它与事务日志（Redo Log）不同，Undo Log 记录的是数据的逻辑变化，而不是物理变化。
- **Undo Log 的清理**：Undo Log 并不会在事务提交后立即删除，因为它可能被其他事务用于 MVCC 操作。因此，Undo Log 的清理通常是由后台的 **Purge（清除）线程** 负责，在确认没有事务再需要这些 Undo Log 时，系统会自动将其清理。

### 2.3.5、**Undo Log 与 Redo Log 的区别**

- **Undo Log** 用于回滚和多版本控制，记录的是数据的旧值，目的是在发生错误或事务回滚时可以撤销操作。
- **Redo Log** 用于数据持久性和崩溃恢复，记录的是数据的修改操作，确保事务提交后的数据不会丢失，即使系统崩溃也能通过重做日志恢复数据。

### 2.3.6、 **事务隔离级别与 Undo Log**

InnoDB 支持的事务隔离级别（如 `READ COMMITTED`、`REPEATABLE READ` 等）通过 Undo Log 实现了不同级别的并发控制。特别是在 **可重复读（REPEATABLE READ）** 隔离级别下，事务在整个执行期间能够看到数据的快照版本，即使其他事务在修改数据，当前事务仍然能读取修改前的版本，而这些版本信息是通过 Undo Log 实现的。

# 七、索引

## 计算B+树高

思路：先计算叶子结点数量，再由每个页快的指针数量逐渐推出高度

- 设主键索引大小为x B，数据总量为w条，行数据大小为y B，页快大小为s B（默认的innodb_page_size大小为16KB）
  - 每个叶子结点存储数据量为 *a = floor(s / y)*，那么叶子结点数量为 *t = ceil(w / a)*
  - 非叶子结点存储索引和指针，设存储索引为 n 个，指针大小为8B，那么 有 *xn + 8(n+1) <= s* ，
  - 那么非叶子结点的指针 *p=n+1*个
  - 树高 *h = ceil( lg(t) / lg(p) )*
- 联合索引叶子结点保存索引值和指向行数据的指针，*y = 索引大小 + 8B*

## 索引失效情况

- 最左前缀规则

  - 条件不包含索引左部
  - 范围查询使用 > < ，不能精确查找

- 索引列运算

  ```sql
  select * from  user  where  substring(phone,10,2) = '15';
  ```

- 头部模糊匹配

  ```sql
  select * from  user  where name like '%文皓';
  ```

- or 连接条件

  当or连接的条件，左右两侧字段都有索引时，索引才会生效。查询引擎会使用两个索引来查询并取并集。当一侧没有索引时就要全表扫描，所以就放弃了有索引的查询。

  - 当使用联合索引时，会失效，但只涉及一列，会走索引

    ```sql
    SELECT * FROM table WHERE A = 10 OR A = 20;
    ```

- 数据分布影响

  优化器认为走索引不如走全表扫描，如查询的数据占全表99%

# 八、查询性能优化

## 8.1、典型满慢查询案例：

- 查询不需要记录——分页查询
- 总是取出全部列——select * 
- 重复查询相同数据——使用缓存

## 8.2、是否在扫描额外记录

### 8.2.1、explain

- explain的**type**字段可以看到表的扫描方式
- rows是扫描行数
- filtered查看返回数据占扫描百分比

### 8.2.2、使用索引覆盖扫描，减少回表查询

- 建立联合索引包含需要返回的数据
- where 条件符合最左前缀原则

## 8.3、重构查询方式

### 8.3.1、切分查询

将一个大查询分成几个小查询，“分而治之”

### 8.3.2、分解连接查询

一个多表查询可能需要查询多个数据进行最终查询

- 缓存。某些查询结构已经被缓存了，就可以跳过这个查询，减少查询次数
- 单个查询减少锁的竞争
- 应用层做连接，更容易对数据库拆分。减少冗余记录访问，数据库连接可能重复访问部分数据

## 8.4、优化器优化

- 重新定义连接表的顺序
- 将外连接转化为内连接
- 优化count()，min()，max()
- 预估转化为常数表达式
- 覆盖索引扫描
- 子查询优化
  - 减少多个查询多次对数据访问
- 提前终止查询
  - 发现不成立条件
  - limit查询
- 等值传播，等值连接时，条件会作用到连接的列上
- in条件，会对值进行排序做二分查找

## 8.5、排序优化

从性能考虑，应该避免排序或者对大数据量进行排序

不能使用索引排序时

- order by子句中的所有列来自第一个连接表，直接进行文件排序，“Using filesort”
- 其他情况。使用临时表存储结果，然后排序，会多出“Using temporary”

使用索引排序时，“Using index”，order by条件也要满足最左前缀原则



